# [boj-2667] 단지번호붙이기 [python]

## [문제](https://www.acmicpc.net/problem/2606) 

## dfs 의사코드
1. 인접행렬로 입력데이터를 받아온다.
2. graph만큼 방문한 노드를 체크하기 위한 visited 이중배열을 생성한다.
3. 이중 반복문으로 point하나씩 방문되었는지 그 포인트가 "1"인지 확인 후 dfs함수를 호출해 탐색한다.
4. 포인트의 값이 1인곳을 발견하면 '0'으로 만들어주고 방문했다고 visited에 1을 대입한다. 그리고 집 수를 갱신한다. 그다음 현재 포인트에서 상하좌우에서 집을 기준으로 dfs로 탐색을 진행한다.
5. 시작한 정점에서 dfs탐색을 모두 마쳐 종료되었다면 전역으로 선언된 house에 누적된 집의 개수를 배열에 추가하고 house는 다시 0으로 초기화함으로써 단지를 나누어 셀 수 있도록 한다.

### py code
```py
import sys
input = sys.stdin.readline

N = int(input())
graph = [list(input().rstrip()) for i in range(N)]
visited = [[0]*N for i in range(N)]
houses = []
house = 0
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]


def dfs_search(i, j):
    global house
    # 종료 조건
    if i < 0 or j >= N or i >= N or j < 0 or graph[i][j] == '0':
        return
    graph[i][j] = '0'  # 탐색한 지점 0으로 변경
    visited[i][j] = 1  # 방문한 정점 표시
    house += 1  # 마을 수 갱신

    for idx in range(4):
        dfs_search(i + dx[idx], j + dy[idx])
    return

for i in range(N):
    for j in range(N):
        if visited[i][j] == 0 and graph[i][j] == '1':
            dfs_search(i, j)
            houses.append(house)
            house = 0

print(len(houses))
for i in sorted(houses):
    print(i)
```
